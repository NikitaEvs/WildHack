# Используемые паттеры

---
# Порождающие
## Строитель
### Проблема
Необходимо уметь создавать клетки, параметры которых определяются пошагово. Для правильной генерации
нужно учитывать большое количество параметров вероятности. Необходимо уметь генерировать не только
сам класс клеток, но и его сериализацию для сохранения карты.
### Решение
Использование паттерна *Строитель*, что позволяет вынести конструирование объекта за пределы класса.
### Реализация
[Абстрактный строитель](../src/Map/AbstractCellTypeBuilder.h)

[Строитель для класса](../src/Map/CellTypeBuilder.h)

[Строитель сериализации](../src/Map/CellTypeJSONRepresentationBuilder.h)

[Директор](../src/Map/CellTypeDirector.h)
### Проблема
Популяции - объекты, которыми управляет игрок - могут быть травоядными и плотоядными, а так же иметь разные размеры (при инициализации: большой, средний и маленький). Чтобы конструировать животных разных размеров в зависимости от способа питания, нужно при конструировании популяции каждый раз писать много однотипного кода.
### Решение
Применение паттерна "строитель" позволяет вынести конструирование за пределы класса популяции, что улучшает читаемость кода и облегчает конструирование различных типов популяций.
### Реализация
[Абстрактный строитель](../src/Animals/PopulationBuilder.h)

[Строитель травоядной популяции](../src/Animals/HerbivorePopulationBuilder.cpp)

[Строитель плоточдной популяции](../src/Animals/CarnivorePopulationBuilder.cpp)

[Директор](../src/Animals/PopulationDirector.h)

## Синглетон
### Проблема
Необходимо предоставить глобальную точку доступа для объектов, иниициализация которых занимает много
времени, а требуются они часто.
### Решение
Использование паттера *Одиночка*, что позволяет получить глобальную точку доступа к сложным объектам.
### Реализация
[Синглетон для класса с конфигурацией](../src/util/Config.h)

[Синглетон для класса с рандомным генератором](../src/util/Random.h)

[Синглетон для констант интерфейса](../resources/string/string.qml)

[Синглетон для констант интерфейса](../resources/colors/light.qml)

# Структурные
## Фасад
### Проблема
Необходимо по запросу от пользователя проводить большое количество действий с внутренними классами
для поддержки игровой механики.
### Решение
Использование паттерна *Фасад* для обеспечения простого интерфейса взаимодействия с визуализацией.
### Реализация
[Движок для игровой механики](../src/Engine/GameEngine.h)

## Адаптер
### Проблема
Необходимо обеспечивать взаимодействие объектов с разными интерфейсами. Например, GUI и игрового движка.
### Решение
Использование паттерна *Адаптер* для взаимодействия между разными объектами.
### Реализация
[Взаимодействие GUI и движка](../gui/Interface/Gui.h)

[Взаимодействие тестовой системы для GUI и google test](../gui/Test/guiTest.cpp)

## Декоратор
### Проблема
Нужна возможность вызова функции адаптера из интерфейса, для этого ей необходимо придать требуемый стандартом вид.
### Решение
Использование паттерна *Декоратор*
### Реализация
[Некоторые функции в адаптере](../gui/Interface/Gui.h)

## Компоновщик
### Проблема
Мутации определяют как в течении игры изменяются параметры популяции. Причем у конкрутной популяции появляется много мутаций, которые могу образовывать дерево. Нужно уметь подсчитывать как совокупность всех мутаций меняет параметры популяции, а так же добавлять новые мутации.
### Решение
Применение паттерна "компоновщик" позволят сконструировать дерево мутаций, в котором могут храниться как сами мутации, так и узлы, в которых эти мутации расходятся и легко вычислять необходимые нам параметры. 
### Реализация
[Абстрактный компонент дерева мутаций](../src/Animals/Mutations/MutationComponent.h)

[Мутация "лист"](../src/Animals/Mutations/LeafMutation.h)

[Контейнер мутаций](../src/Animals/Mutations/CompoundMutation.h)